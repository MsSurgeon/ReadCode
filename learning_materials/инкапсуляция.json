{
  "topic": "Инкапсуляция в Python",
  "introduction": "Инкапсуляция - это механизм, который позволяет скрывать детали реализации класса от внешнего мира и предоставлять доступ к ним только через установленные интерфейсы. Она позволяет создавать более надежные и безопасные программы, уменьшая зависимость кода друг от друга. В Python инкапсуляция реализуется с помощью использования соглашений об именовании, свойств, геттеров и сеттеров, а также модуля dataclasses для создания классов данных.",
  "theory": {
    "overview": "Инкапсуляция - это принцип объектно-ориентированного программирования, который позволяет объединять данные и методы работы с ними внутри класса, скрывая детали реализации от внешнего кода. Основная идея заключается в том, что данные класса должны быть доступны только через методы класса, что обеспечивает контролируемый доступ к ним.",
    "best_practices": [
      "Используйте префиксы '_' и '__' для обозначения приватных атрибутов и методов.",
      "Используйте свойства (properties) для доступа к приватным атрибутам с дополнительной логикой.",
      "Используйте геттеры и сеттеры для контролируемого доступа к атрибутам.",
      "Используйте модуль dataclasses для создания классов данных с автоматической реализацией методов доступа."
    ],
    "common_mistakes": [
      "Излишнее использование инкапсуляции может привести к излишней сложности кода.",
      "Игнорирование соглашений об именовании для обозначения приватных атрибутов может привести к непредсказуемому поведению.",
      "Неправильное использование свойств, геттеров и сеттеров может усложнить код и сделать его менее читаемым."
    ]
  },
  "examples": [
    {
      "title": "Пример использования соглашений об именовании",
      "description": "Пример показывает как использовать префиксы '_' и '__' для обозначения приватных атрибутов и методов.",
      "code": "class MyClass:\n    def __init__(self):\n        self._private_attr = 10\n        self.__private_method()\n    \n    def __private_method(self):\n        print('This is a private method')",
      "explanation": "В данном примере атрибут '_private_attr' и метод '__private_method' являются приватными и не должны быть доступны извне класса."
    },
    {
      "title": "Пример использования свойств (properties)",
      "description": "Пример демонстрирует использование свойств для доступа к приватным атрибутам с дополнительной логикой.",
      "code": "class Circle:\n    def __init__(self, radius):\n        self._radius = radius\n    \n    @property\n    def radius(self):\n        return self._radius\n    \n    @radius.setter\n    def radius(self, value):\n        if value > 0:\n            self._radius = value\n        else:\n            raise ValueError('Радиус должен быть положительным числом')",
      "explanation": "Здесь свойство 'radius' позволяет получать и устанавливать значение радиуса круга с проверкой на положительность."
    },
    {
      "title": "Пример использования модуля dataclasses",
      "description": "Пример показывает как использовать модуль dataclasses для создания класса данных с автоматической реализацией методов доступа.",
      "code": "from dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: int\n    y: int",
      "explanation": "С помощью модуля dataclasses можно быстро создавать классы данных, автоматически генерируя методы доступа к атрибутам."
    }
  ],
  "practice_examples": {
    "examples": [
      {
        "code": "class Person:\n    def __init__(self, name, age):\n        self._name = name\n        self._age = age\n    \n    @property\n    def name(self):\n        return self._name\n    \n    @property\n    def age(self):\n        return self._age\n    \n    @age.setter\n    def age(self, value):\n        if value >= 0:\n            self._age = value\n        else:\n            raise ValueError('Возраст должен быть неотрицательным числом')",
        "hidden_explanation": "Класс Person представляет собой пример инкапсуляции в Python. У класса есть приватные атрибуты _name и _age, которые доступны только через методы name и age. Метод age также содержит сеттер для проверки на неотрицательное значение возраста.",
        "expected_concepts": [
          "Приватные атрибуты",
          "Геттеры",
          "Сеттеры",
          "Инкапсуляция"
        ],
        "id": "инкапсуляция_в_python_ex1"
      },
      {
        "code": "class BankAccount:\n    def __init__(self, balance):\n        self._balance = balance\n    \n    def deposit(self, amount):\n        self._balance += amount\n    \n    def withdraw(self, amount):\n        if amount <= self._balance:\n            self._balance -= amount\n        else:\n            raise ValueError('Недостаточно средств на счету')",
        "hidden_explanation": "Класс BankAccount демонстрирует инкапсуляцию в действии. Атрибут _balance является приватным и доступен только через методы deposit и withdraw, которые обеспечивают безопасное изменение баланса с проверкой наличия достаточных средств.",
        "expected_concepts": [
          "Приватные атрибуты",
          "Методы доступа",
          "Инкапсуляция",
          "Исключения"
        ],
        "id": "инкапсуляция_в_python_ex2"
      }
    ]
  }
}