{
  "topic": "Многопоточность и параллельное программирование в Python",
  "introduction": "Многопоточность и параллельное программирование в Python позволяют создавать эффективные и быстрые программы за счет одновременного выполнения нескольких задач. Это особенно важно в современных вычислительных системах, где процессоры имеют множество ядер. Работа с модулями threading, multiprocessing, concurrent.futures и asyncio позволяет эффективно использовать вычислительные ресурсы и улучшить производительность программы. Важно понимать концепции GIL, синхронизации потоков, пулов процессов и асинхронного программирования на основе корутин.",
  "theory": {
    "overview": "Многопоточность в Python позволяет создавать потоки выполнения, которые могут работать параллельно. Модуль threading используется для работы с потоками, но из-за GIL только один поток может выполняться в каждый момент времени. Модуль multiprocessing позволяет создавать процессы, каждый из которых имеет свой собственный интерпретатор Python и может использовать все ядра процессора. Модуль concurrent.futures предоставляет высокоуровневый интерфейс для работы с потоками и процессами. Асинхронное программирование на базе asyncio и корутин позволяет эффективно обрабатывать асинхронные задачи без блокировки потоков.",
    "best_practices": [
      "Используйте многопоточность и параллельное программирование для выполнения задач, которые могут быть разделены на независимые подзадачи.",
      "Избегайте использования синхронизации потоков в многопоточных программах, если это необходимо, используйте механизмы блокировки.",
      "Оценивайте производительность программы и выбирайте подходящий метод параллелизации: потоки или процессы.",
      "Используйте асинхронное программирование для обработки большого количества асинхронных задач без задержек."
    ],
    "common_mistakes": [
      "Неправильное использование синхронизации потоков может привести к состоянию гонки и блокировкам.",
      "Неправильный выбор между потоками и процессами может ухудшить производительность программы.",
      "Избегайте блокировки потоков на длительные операции, используйте асинхронное программирование для таких задач."
    ]
  },
  "examples": [
    {
      "title": "Пример 1: Создание потока с помощью threading",
      "description": "Пример создания и запуска потока выполнения с использованием модуля threading.",
      "code": "import threading\n\ndef print_numbers():\n    for i in range(1, 6):\n        print(i)\n\n# Создание и запуск потока\nthread = threading.Thread(target=print_numbers)\nthread.start()",
      "explanation": "В этом примере создается функция print_numbers, которая просто выводит числа от 1 до 5. Затем создается объект потока threading.Thread с указанием целевой функции print_numbers и запускается методом start(). После запуска поток начнет выполнение функции print_numbers параллельно с основным потоком."
    },
    {
      "title": "Пример 2: Создание процесса с помощью multiprocessing",
      "description": "Пример создания и запуска процесса с использованием модуля multiprocessing.",
      "code": "import multiprocessing\n\ndef square(n):\n    return n * n\n\nif __name__ == '__main__':\n    # Создание и запуск процесса\n    process = multiprocessing.Process(target=square, args=(5,))\n    process.start()\n    process.join()",
      "explanation": "В этом примере создается функция square, которая принимает число и возвращает его квадрат. Затем создается объект процесса multiprocessing.Process с указанием целевой функции square и аргументами (5,) и запускается методом start(). Метод join() позволяет дождаться завершения процесса. После запуска процесс начнет выполнение функции square параллельно с основным процессом."
    },
    {
      "title": "Пример 3: Асинхронное программирование с asyncio",
      "description": "Пример использования asyncio для асинхронного выполнения задач.",
      "code": "import asyncio\n\nasync def greet():\n    print('Hello')\n    await asyncio.sleep(1)\n    print('World')\n\n# Создание и запуск корутины\nasyncio.run(greet())",
      "explanation": "В этом примере создается асинхронная функция greet, которая выводит 'Hello', ждет 1 секунду с помощью await asyncio.sleep(1) и затем выводит 'World'. Функция asyncio.run(greet()) запускает корутину greet, которая выполняется асинхронно, позволяя другим задачам выполняться во время ожидания."
    }
  ],
  "practice_examples": {
    "examples": [
      {
        "code": "import threading\n\ndef print_numbers():\n    for i in range(1, 6):\n        print(i)\n\n# Создание и запуск потока\nthread = threading.Thread(target=print_numbers)\nthread.start()",
        "hidden_explanation": "Этот код создает поток выполнения, который выводит числа от 1 до 5 параллельно с основным потоком.",
        "expected_concepts": [
          "Многопоточность",
          "Модуль threading",
          "Создание потока",
          "Запуск потока",
          "Параллельное выполнение"
        ],
        "id": "многопоточность_и_параллельное_программирование_в_python_ex1"
      },
      {
        "code": "import multiprocessing\n\ndef square(n):\n    return n * n\n\nif __name__ == '__main__':\n    # Создание и запуск процесса\n    process = multiprocessing.Process(target=square, args=(5,))\n    process.start()\n    process.join()",
        "hidden_explanation": "Этот код создает процесс, который вычисляет квадрат числа 5 параллельно с основным процессом.",
        "expected_concepts": [
          "Параллельное программирование",
          "Модуль multiprocessing",
          "Создание процесса",
          "Запуск процесса",
          "Параллельное выполнение"
        ],
        "id": "многопоточность_и_параллельное_программирование_в_python_ex2"
      },
      {
        "code": "import asyncio\n\nasync def greet():\n    print('Hello')\n    await asyncio.sleep(1)\n    print('World')\n\n# Создание и запуск корутины\nasyncio.run(greet())",
        "hidden_explanation": "Этот код использует asyncio для асинхронного вывода 'Hello' и 'World' с задержкой в 1 секунду.",
        "expected_concepts": [
          "Асинхронное программирование",
          "Модуль asyncio",
          "Асинхронные функции",
          "Ожидание выполнения",
          "Корутины"
        ],
        "id": "многопоточность_и_параллельное_программирование_в_python_ex3"
      },
      {
        "code": "from concurrent.futures import ThreadPoolExecutor\n\n# Функция для выполнения в потоке\ndef square(n):\n    return n * n\n\n# Создание пула потоков\nwith ThreadPoolExecutor() as executor:\n    # Запуск задачи\n    future = executor.submit(square, 5)\n    # Получение результата\n    result = future.result()\n    print(result)",
        "hidden_explanation": "Этот код создает пул потоков для вычисления квадрата числа 5 и выводит результат.",
        "expected_concepts": [
          "Пул потоков",
          "Модуль concurrent.futures",
          "Создание пула потоков",
          "Запуск задачи в пуле",
          "Получение результатов"
        ],
        "id": "многопоточность_и_параллельное_программирование_в_python_ex4"
      },
      {
        "code": "from concurrent.futures import ProcessPoolExecutor\n\n# Функция для выполнения в процессе\ndef cube(n):\n    return n * n * n\n\n# Создание пула процессов\nwith ProcessPoolExecutor() as executor:\n    # Запуск задачи\n    future = executor.submit(cube, 3)\n    # Получение результата\n    result = future.result()\n    print(result)",
        "hidden_explanation": "Этот код создает пул процессов для вычисления куба числа 3 и выводит результат.",
        "expected_concepts": [
          "Пул процессов",
          "Модуль concurrent.futures",
          "Создание пула процессов",
          "Запуск задачи в пуле",
          "Получение результатов"
        ],
        "id": "многопоточность_и_параллельное_программирование_в_python_ex5"
      }
    ]
  }
}