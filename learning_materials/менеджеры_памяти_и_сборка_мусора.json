{
  "topic": "Менеджеры памяти и сборка мусора в Python",
  "introduction": "Управление памятью в Python крайне важно для эффективной работы программы. В данной теме мы рассмотрим ключевые механизмы, такие как подсчет ссылок, циклический сборщик мусора и слабые ссылки (weakref). Мы также изучим оптимизацию использования памяти, профилирование и выявление утечек памяти.",
  "theory": {
    "overview": "Менеджеры памяти в Python отвечают за выделение и освобождение памяти, а также за управление объектами. Подсчет ссылок позволяет определить, когда объект может быть удален из памяти. Циклический сборщик мусора автоматически находит и удаляет недостижимые объекты в циклических ссылках. Слабые ссылки (weakref) позволяют создавать ссылки на объекты, не увеличивая их счетчик ссылок.",
    "best_practices": [
      "Используйте контекстные менеджеры для управления ресурсами и автоматического освобождения памяти",
      "Избегайте циклических ссылок, так как они могут привести к утечкам памяти",
      "Используйте слабые ссылки (weakref) там, где необходимо избежать увеличения счетчика ссылок"
    ],
    "common_mistakes": [
      "Неправильное использование сильных ссылок вместо слабых ссылок",
      "Недостаточное внимание к профилированию и оптимизации использования памяти",
      "Не освобождение ресурсов после использования"
    ]
  },
  "examples": [
    {
      "title": "Пример 1: Подсчет ссылок",
      "description": "Пример демонстрирует работу подсчета ссылок в Python",
      "code": "class MyClass:\n    def __init__(self, name):\n        self.name = name\n\nobj = MyClass('example')\nprint(sys.getrefcount(obj))",
      "explanation": "В данном примере создается объект MyClass и выводится количество ссылок на него. Функция sys.getrefcount возвращает количество ссылок на объект, включая внутренние ссылки. Обычно это значение будет на 1 больше, чем ожидается из-за временных ссылок."
    },
    {
      "title": "Пример 2: Циклический сборщик мусора",
      "description": "Пример иллюстрирует работу циклического сборщика мусора в Python",
      "code": "import gc\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n# Создание циклической ссылки\nnode1 = Node(1)\nnode2 = Node(2)\nnode1.next = node2\nnode2.next = node1\n\n# Принудительный запуск сборщика мусора\ngc.collect()",
      "explanation": "В данном примере создаются два объекта Node, которые ссылаются друг на друга, создавая циклическую ссылку. После принудительного запуска сборщика мусора (gc.collect()), циклический сборщик мусора обнаруживает и удаляет эти объекты из памяти."
    },
    {
      "title": "Пример 3: Использование слабых ссылок",
      "description": "Пример демонстрирует использование слабых ссылок (weakref) в Python",
      "code": "import weakref\n\nclass MyClass:\n    def __init__(self, name):\n        self.name = name\n\nobj = MyClass('example')\nref = weakref.ref(obj)\nprint(ref())",
      "explanation": "В данном примере создается объект MyClass и создается слабая ссылка на него с помощью weakref.ref. После удаления всех сильных ссылок на объект, слабая ссылка возвращает None, что позволяет объекту быть удаленным автоматически."
    }
  ],
  "practice_examples": {
    "examples": [
      {
        "code": "class MyClass:\n    def __init__(self, name):\n        self.name = name\n\nobj = MyClass('example')\nprint(sys.getrefcount(obj))",
        "hidden_explanation": "Этот пример демонстрирует работу подсчета ссылок в Python. Создается экземпляр класса MyClass, после чего выводится количество ссылок на этот объект с помощью функции sys.getrefcount.",
        "expected_concepts": [
          "Подсчет ссылок",
          "Классы и методы в Python",
          "Инициализация объектов",
          "Функция sys.getrefcount",
          "Управление памятью"
        ],
        "id": "менеджеры_памяти_и_сборка_мусора_в_python_ex1"
      },
      {
        "code": "import gc\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n# Создание циклической ссылки\nnode1 = Node(1)\nnode2 = Node(2)\nnode1.next = node2\nnode2.next = node1\n\n# Принудительный запуск сборщика мусора\ngc.collect()",
        "hidden_explanation": "Этот пример иллюстрирует работу циклического сборщика мусора в Python. Создаются два объекта Node, которые ссылаются друг на друга, образуя циклическую ссылку. После принудительного запуска сборщика мусора (gc.collect()), циклический сборщик мусора обнаруживает и удаляет эти объекты из памяти.",
        "expected_concepts": [
          "Циклический сборщик мусора",
          "Импорт модулей",
          "Создание классов и объектов",
          "Принудительный запуск сборщика мусора",
          "Управление памятью"
        ],
        "id": "менеджеры_памяти_и_сборка_мусора_в_python_ex2"
      },
      {
        "code": "import weakref\n\nclass MyClass:\n    def __init__(self, name):\n        self.name = name\n\nobj = MyClass('example')\nref = weakref.ref(obj)\nprint(ref())",
        "hidden_explanation": "Этот пример демонстрирует использование слабых ссылок (weakref) в Python. Создается экземпляр класса MyClass, затем создается слабая ссылка на этот объект с помощью weakref.ref. После удаления всех сильных ссылок на объект, слабая ссылка возвращает None, что позволяет объекту быть удаленным автоматически.",
        "expected_concepts": [
          "Слабые ссылки (weakref)",
          "Импорт модулей",
          "Инициализация объектов",
          "Механизмы управления ссылками",
          "Автоматическое удаление объектов"
        ],
        "id": "менеджеры_памяти_и_сборка_мусора_в_python_ex3"
      }
    ]
  }
}